<h2>함수와 객체 지향 프로그래밍</h2>
작성자: Alpine_Dolce&nbsp;&nbsp;|&nbsp;&nbsp;날짜: 2025-07-04

<h2>문서 목표</h2>
<p>이 문서는 JavaScript의 핵심 문법과 주요 개념을 체계적으로 정리하여, 동적인 웹 페이지를 개발하는 능력을 기르는 것을 목표로 합니다. 변수 선언, 함수, 객체, 비동기 처리 등 필수 개념들을 상세한 코드 예제와 함께 학습하여 실무 활용도를 높이고자 합니다.</p>

<h2>목차</h2>

- [2. 함수와 객체 지향 프로그래밍](#2-함수와-객체-지향-프로그래밍)
  - [2.1. 함수 (Functions)](#21-함수-functions)
    - [2.1.1. 함수 선언문, 함수 표현식, 화살표 함수](#211-함수-선언문-함수-표현식-화살표-함수)
    - [2.1.2. 콜백 함수](#212-콜백-함수)
    - [2.1.3. 클로저 (Closures)](#213-클로저-closures)
    - [2.1.4. 고차 함수 (Higher-Order Functions)](#214-고차-함수-higher-order-functions)
  - [2.2. 객체 (Objects)와 JSON](#22-객체-objects와-json)
  - [2.3. 프로토타입과 프로토타입 상속 (Prototype & Prototypal Inheritance)](#23-프로토타입과-프로토타입-상속-prototype--prototypal-inheritance)
  - [2.4. 클래스 (Classes)](#24-클래스-classes)
  - [2.5. 배열과 주요 메서드 (Array & Methods)](#25-배열과-주요-메서드-array--methods)

---

## 2. 함수와 객체 지향 프로그래밍

### 2.1. 함수 (Functions)

특정 작업을 수행하는 코드 블록으로, 재사용이 가능합니다.

#### 2.1.1. 함수 선언문, 함수 표현식, 화살표 함수
- **함수 선언문 (Function Declaration)**: `function` 키워드로 함수를 정의하는 가장 일반적인 방법입니다. 호이스팅의 대상이 되어, 코드의 어디서든 호출할 수 있습니다.

    **코드 사례 (`함수1.js`):
    ```javascript
    // 1~N까지 더해서 출력하는 함수
    function sigma(limit = 10) { // 매개변수 기본값 설정
        let s = 0;
        for(let i = 1; i <= limit; i++) {
            s += i;
        }
        return s;
    }
    console.log(sigma(100)); // 5050
    ```

- **함수 표현식 (Function Expression)**: 변수에 익명 함수(이름 없는 함수)를 할당하는 방식입니다. 변수에 할당되기 전에는 호출할 수 없습니다.

    **코드 사례 (`함수1.js`):
    ```javascript
    let add = function(x, y) { 
        return x + y; 
    };
    console.log(add(10, 20)); // 30
    ```

- **화살표 함수 (Arrow Function)**: `=>` 기호를 사용하여 함수를 더 간결하게 표현하는 방식입니다. `function` 키워드와 `return`을 생략할 수 있으며, `this`를 바인딩하지 않는 특징이 있습니다. (객체 메서드에서는 주의 필요)

    **코드 사례 (`함수1.js`):
    ```javascript
    const add = (x, y) => x + y;
    console.log(add(10, 20)); // 30

    // 배열 메서드와 함께 사용할 때 매우 유용합니다.
    let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    let result = arr.filter(a => a % 2 == 0); // 짝수만 필터링
    console.log(result); // [2, 4, 6, 8, 10]
    ```

#### 2.1.2. 콜백 함수
- **콜백 함수 (Callback Function)**: 다른 함수의 인자로 전달되어, 그 함수 안에서 실행되는 함수를 말합니다. 비동기 처리나 이벤트 핸들러에서 핵심적인 역할을 합니다.

    **코드 사례 (`콜백1.js`):
    ```javascript
    function myfunc(callback, x, y) {
        // 전달받은 callback 함수를 실행
        const result = callback(x, y);
        console.log(`결과: ${result}`);
    }

    function add(x, y) {
        return x + y;
    }

    // add 함수를 콜백으로 전달
    myfunc(add, 8, 7); // 결과: 15

    // 화살표 함수를 콜백으로 전달
    myfunc((x, y) => x * y, 8, 7); // 결과: 56
    ```

#### 2.1.3. 클로저 (Closures)
- **클로저 (Closures)**: 클로저는 함수와 함수가 선언될 당시의 렉시컬(어휘적) 환경의 조합입니다. 즉, 함수가 생성될 때 그 함수가 접근할 수 있는 변수들을 기억하는 것입니다. 이를 통해 함수가 자신의 외부 함수 스코프에 있는 변수에 접근할 수 있게 됩니다. JavaScript의 강력한 기능 중 하나로, 데이터 은닉, 부분 적용 함수, 모듈 패턴 등에 활용됩니다.

    **코드 사례:**
    ```javascript
    function makeCounter() {
        let count = 0; // makeCounter의 렉시컬 환경에 속하는 변수
        return function() {
            return count++; // 외부 함수의 변수 count에 접근
        };
    }

    const counter1 = makeCounter();
    console.log(counter1()); // 0
    console.log(counter1()); // 1

    const counter2 = makeCounter();
    console.log(counter2()); // 0 (새로운 렉시컬 환경)
    ```

#### 2.1.4. 고차 함수 (Higher-Order Functions)
- **고차 함수 (Higher-Order Functions)**: 고차 함수는 다음 중 하나 이상을 수행하는 함수를 의미합니다.
    1.  하나 이상의 함수를 인자로 받습니다.
    2.  함수를 결과로 반환합니다.

    JavaScript의 `map`, `filter`, `reduce`와 같은 배열 메서드들이 대표적인 고차 함수입니다. 고차 함수는 코드의 재사용성을 높이고, 함수형 프로그래밍 스타일을 가능하게 합니다.

    **코드 사례:**
    ```javascript
    // 함수를 인자로 받는 고차 함수
    function operateOnNumbers(operation, a, b) {
        return operation(a, b);
    }

    function add(x, y) { return x + y; }
    function multiply(x, y) { return x * y; }

    console.log(operateOnNumbers(add, 5, 3));      // 8
    console.log(operateOnNumbers(multiply, 5, 3)); // 15

    // 함수를 반환하는 고차 함수 (클로저와 함께 사용)
    function createMultiplier(multiplier) {
        return function(number) {
            return number * multiplier;
        };
    }

    const double = createMultiplier(2);
    const triple = createMultiplier(3);

    console.log(double(10));  // 20
    console.log(triple(10));  // 30
    ```

### 2.2. 객체 (Objects)와 JSON

JavaScript에서 객체는 **키(key)와 값(value)의 쌍**으로 이루어진 데이터의 집합입니다. 관련된 데이터와 기능을 하나로 묶어 관리할 수 있습니다.

- **객체 리터럴 (Object Literal)**: 중괄호(`{}`)를 사용하여 객체를 만드는 가장 일반적인 방법입니다. 키는 문자열이나 심볼 값을 가지며, 값은 원시 값, 다른 객체, 또는 함수가 될 수 있습니다.

    **코드 사례 (`객체1.js`):
    ```javascript
    // 키에 특수문자(-)가 포함되면 따옴표로 감싸야 합니다.
    let user = { "student-name": "홍길동", kor: 90, eng: 80, mat: 80 };

    // 속성 접근 방법
    console.log(user.kor); // 점 표기법 (Dot notation)
    console.log(user["student-name"]); // 대괄호 표기법 (Bracket notation)

    // 새로운 속성 추가
    user.total = user.kor + user.eng + user.mat;
    user.avg = user.total / 3;

    console.log(user);
    ```

- **객체와 메서드**: 객체의 속성 값으로 함수를 가질 수 있으며, 이를 **메서드(Method)**라고 부릅니다. 메서드 내에서 `this` 키워드를 사용하면 객체 자신의 다른 속성에 접근할 수 있습니다.

    > **주의:** 화살표 함수는 자신만의 `this`를 가지지 않으므로, 객체의 메서드를 정의할 때는 `function` 키워드를 사용한 함수 표현식을 사용해야 합니다.

    **코드 사례 (`객체2.js`):
    ```javascript
    let person = {
        name: "홍길동",
        age: 23,
        // display는 person 객체의 메서드입니다.
        display: function() {
            // this는 person 객체 자신을 가리킵니다.
            console.log(`${this.name} / ${this.age}`);
        },
        setValue: function(name, age) {
            this.name = name;
            this.age = age;
        }
    };

    person.setValue("임꺽정", 33);
    person.display(); // 출력: 임꺽정 / 33
    ```

- **JSON (JavaScript Object Notation)**: 데이터를 교환하기 위한 경량의 데이터 형식입니다. JavaScript 객체 리터럴과 매우 유사하지만 몇 가지 차이점이 있습니다.
    - **키(key)는 반드시 큰따옴표(`"`)로 감싸야 합니다.**
    - 값으로 함수나 생성자를 가질 수 없으며, 순수한 데이터만 표현합니다.
    - 네트워크를 통해 데이터를 주고받을 때는 객체를 JSON 형태의 **문자열**로 변환하여 사용합니다.
        - `JSON.stringify()`: JavaScript 객체를 JSON 문자열로 변환합니다.
        - `JSON.parse()`: JSON 문자열을 JavaScript 객체로 변환합니다.

    **코드 사례 (`예외처리.js`):
    ```javascript
    // 서버로부터 받은 JSON 형태의 문자열이라고 가정
    let jsonString = '{"name":"홍길동","age":23}';

    try {
        // JSON 문자열을 JavaScript 객체로 파싱
        let user = JSON.parse(jsonString);
        console.log(user.name); // 출력: 홍길동
    } catch(e) {
        console.error("JSON 파싱 에러:", e);
    }
    ```


### 2.3. 프로토타입과 프로토타입 상속 (Prototype & Prototypal Inheritance)

JavaScript는 프로토타입 기반 언어입니다. 모든 객체는 자신의 부모 역할을 하는 다른 객체, 즉 **프로토타입(Prototype)**을 가지며, 프로토타입 체인을 통해 상속을 구현합니다.

- **생성자 함수와 `prototype` 프로퍼티**: `new` 키워드로 객체를 생성하면, 생성자 함수의 `prototype` 프로퍼티가 새로 생성된 객체의 프로토타입이 됩니다. 클래스 문법은 이러한 프로토타입 상속을 더 쉽게 사용할 수 있도록 만든 문법적 설탕입니다.

### 2.4. 클래스 (Classes)

ES6부터 도입된 클래스 문법은 객체를 생성하기 위한 템플릿(틀)입니다. 기존의 프로토타입 기반 상속을 더 명확하고 간결하게 사용할 수 있게 해주는 **문법적 설탕(Syntactic Sugar)**입니다.

- **`class`와 `constructor`**: `class` 키워드로 클래스를 정의하고, `constructor` (생성자) 메서드를 사용하여 객체가 생성될 때 초기 상태를 설정합니다.
- **메서드**: 클래스 내부에 함수를 정의하여 해당 클래스로부터 생성된 모든 객체가 공유하는 기능을 만듭니다.
- **상속 (`extends`와 `super`)**: 다른 클래스의 속성과 메서드를 물려받아 새로운 클래스를 만들 수 있습니다.
    - `extends`: 상속할 부모 클래스를 지정합니다.
    - `super`: 부모 클래스의 생성자나 메서드를 호출할 때 사용합니다.

    **코드 사례 (`클래스1.js` 보강):
    ```javascript
    // 부모 클래스
    class Person {
        constructor(name = "", age = 0) {
            this.name = name;
            this.age = age;
        }

        display() {
            console.log(`이름: ${this.name}, 나이: ${this.age}`);
        }
    }

    // 자식 클래스 (Person을 상속)
    class Student extends Person {
        constructor(name, age, studentId) {
            super(name, age); // 부모 클래스의 생성자 호출
            this.studentId = studentId;
        }

        // 메서드 오버라이딩(재정의)
        display() {
            console.log(`이름: ${this.name}, 나이: ${this.age}, 학번: ${this.studentId}`);
        }
    }

    let student1 = new Student("김학생", 20, "2024001");
    student1.display(); // 출력: 이름: 김학생, 나이: 20, 학번: 2024001
    ```

### 2.5. 배열과 주요 메서드 (Array & Methods)

배열은 순서가 있는 값의 목록입니다. JavaScript 배열은 강력하고 유용한 내장 메서드를 많이 제공하여 데이터 처리를 쉽게 만듭니다.

- **`filter()`**: 주어진 함수의 테스트를 통과하는 **모든 요소**를 모아 **새로운 배열**로 반환합니다.

    **코드 사례 (`함수1.js`):
    ```javascript
    let words = ["rain", "umbrella", "desk", "note", "assembly"];

    // 단어 길이가 5 이상인 단어만 필터링
    const longWords = words.filter(word => word.length >= 5);
    console.log(longWords); // ["umbrella", "assembly"]

    // 'h' 또는 'r'로 시작하는 단어 필터링
    const startWithHR = words.filter(e => e.startsWith("h") || e.startsWith("r"));
    console.log(startWithHR); // ["rain"]
    ```

- **`map()`**: 배열의 각 요소에 대해 주어진 함수를 실행하고, 그 **결과를 모아 새로운 배열**로 반환합니다. 원본 배열을 변경하지 않으며, 요소의 개수도 동일합니다.

    **코드 사례 (`함수2.js`):
    ```javascript
    let arr = [2, 3, 4, 5, 6];

    // 각 요소를 2배로 만든 새로운 배열 생성
    const doubledArr = arr.map(x => x * 2);
    console.log(doubledArr); // [4, 6, 8, 10, 12]

    let words = ["cloud", "rainy", "heavy"];
    // 각 단어를 대문자로 변환
    const upperWords = words.map(x => x.toUpperCase());
    console.log(upperWords); // ["CLOUD", "RAINY", "HEAVY"]
    ```

- **`find()`**: 주어진 함수의 테스트를 통과하는 **첫 번째 요소 하나**를 반환합니다. `filter`와 유사하지만, 배열이 아닌 단일 값을 반환하며, 일치하는 요소를 찾으면 즉시 검색을 중단합니다. (찾지 못하면 `undefined` 반환)

    **코드 사례 (`함수2.js`):
    ```javascript
    let arr = [2, 3, 4, 5, 6, 7, 9, 11, 13];

    // 첫 번째 짝수 찾기
    const firstEven = arr.find(x => x % 2 == 0);
    console.log(firstEven); // 2
    ```

- **`reduce()`**: 배열의 각 요소에 대해 (왼쪽에서 오른쪽으로) 누적 계산을 수행하여 **하나의 결과값**을 반환합니다. 배열의 총합, 평균, 최대값 등을 구할 때 유용합니다.

    **코드 사례 (`함수2.js`):
    ```javascript
    // arr.reduce((누적값, 현재값) => { ... }, 초기값);
    let arr = [2, 3, 4, 5, 6];

    // 배열의 모든 요소의 합계 구하기
    const sum = arr.reduce((accumulator, currentValue) => accumulator + currentValue, 0);
    console.log(sum); // 20
    ```

- **`sort()`**: 배열의 요소를 정렬합니다. 기본적으로는 유니코드 코드 포인트 순서(문자열로 변환 후)로 정렬하므로, 숫자를 제대로 정렬하려면 **비교 함수(compare function)**를 인자로 제공해야 합니다.

    **코드 사례 (`함수2.js`):
    ```javascript
    let arr = [13, 2, 9, 11, 3];

    // 오름차순 정렬
    arr.sort((a, b) => a - b);
    console.log(arr); // [2, 3, 9, 11, 13]

    // 내림차순 정렬
    arr.sort((a, b) => b - a);
    console.log(arr); // [13, 11, 9, 3, 2]

    // 객체 배열 정렬
    let items = [
      { name: "Edward", value: 21 },
      { name: "Sharpe", value: 37 },
      { name: "And", value: 45 }
    ];
    // value 속성 기준으로 오름차순 정렬
    items.sort((x1, x2) => x1.value - x2.value);
    console.log(items);
    ```