<h2>JavaScript 고급 개념</h2>
작성자: Alpine_Dolce&nbsp;&nbsp;|&nbsp;&nbsp;날짜: 2025-07-04

<h2>문서 목표</h2>
<p>이 문서는 JavaScript의 모듈 시스템, 예외 처리, 정규 표현식, 메모리 관리 등 핵심 고급 개념을 체계적으로 정리하여, 안정적이고 효율적인 코드를 작성하는 능력을 기르는 것을 목표로 합니다.</p>

<h2>목차</h2>

- [1. 모듈 시스템 (`import` / `export`)](#1-모듈-시스템-import--export)
- [2. 예외 처리 (Error Handling)](#2-예외-처리-error-handling)
  - [2.1. `try...catch...finally` 및 `throw`](#21-trycatchfinally-및-throw)
  - [2.2. 사용자 정의 에러 (Custom Errors)](#22-사용자-정의-에러-custom-errors)
  - [2.3. 전역 에러 핸들링 (Global Error Handling)](#23-전역-에러-핸들링-global-error-handling)
- [3. 기타 고급 주제 및 실무 기법](#3-기타-고급-주제-및-실무-기법)
  - [3.1. 정규 표현식 (Regular Expressions)](#31-정규-표현식-regular-expressions)
  - [3.2. 메모리 관리 (Memory Management)](#32-메모리-관리-memory-management)
  - [3.3. 성능 최적화 패턴 (Debouncing & Throttling)](#33-성능-최적화-패턴-debouncing--throttling)
  - [3.4. 함수형 프로그래밍 (Functional Programming)](#34-함수형-프로그래밍-functional-programming)

---

## 1. 모듈 시스템 (`import` / `export`)

코드를 여러 파일로 분리하여 재사용성과 유지보수성을 높이는 기능입니다.

- **`export`**: 변수, 함수, 클래스 등을 다른 모듈에서 사용할 수 있도록 내보냅니다.
- **`import`**: 다른 모듈에서 `export`한 것을 가져옵니다.
- **HTML에서 사용**: `<script type="module" src="./main.js"></script>` 처럼 `type="module"` 속성을 추가해야 합니다.

    **코드 사례:**
    ```javascript
    // 📁 math.js
    export const PI = 3.14;
    export default function add(a, b) {
      return a + b;
    }

    // 📁 main.js
    import add, { PI } from './math.js';
    console.log(PI); // 3.14
    console.log(add(5, 3)); // 8
    ```

## 2. 예외 처리 (Error Handling)

코드 실행 중 발생할 수 있는 오류에 대처하고 프로그램이 비정상적으로 종료되는 것을 방지하기 위해 사용됩니다.

### 2.1. `try...catch...finally` 및 `throw`
- **`try...catch...finally` 문**: `try` 블록 안의 코드를 실행하고, 만약 오류가 발생하면 `catch` 블록이 해당 오류 객체를 받아 처리합니다. `finally` 블록은 오류 발생 여부와 상관없이 항상 실행됩니다.

    **코드 사례 (`예외처리.js`):
    ```javascript
    let invalidJsonData = "{ bad json }";

    try {
        console.log("파싱 시도...");
        let user = JSON.parse(invalidJsonData);
        console.log(user.name);
    } catch (e) {
        console.error("예외가 발생했습니다:", e.name, e.message);
    } finally {
        console.log("예외 처리 시도가 완료되었습니다.");
    }
    ```

- **`throw` 문**: 의도적으로 사용자 정의 예외를 발생시킬 수 있습니다. 특정 조건이 만족되지 않았을 때 코드 실행을 중단하고 에러를 알리는 데 유용합니다.

    **코드 사례:**
    ```javascript
    function checkAge(age) {
        if (age < 19) {
            throw new Error("미성년자는 접근할 수 없습니다.");
        }
        return true;
    }

    try {
        checkAge(15);
    } catch (e) {
        console.log(e.message); // "미성년자는 접근할 수 없습니다."
    }
    ```

- **비동기 코드의 예외 처리**: `Promise`나 `async/await`를 사용하는 비동기 코드에서는 예외 처리 방식이 조금 다릅니다.
    - **`Promise`**: `.then()` 체인 끝에 `.catch()` 메서드를 사용하여 이전 `Promise`에서 발생한 모든 에러를 한 번에 처리할 수 있습니다.
    - **`async/await`**: 동기 코드와 마찬가지로 `try...catch` 문을 사용하여 `await` 키워드로 실행한 `Promise`에서 발생한 에러를 잡을 수 있습니다.

    **코드 사례 (비동기 예외 처리):**
    ```javascript
    // Promise의 .catch()를 사용한 예외 처리
    fetch('https://api.example.com/invalid-url')
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP 에러! 상태: ${response.status}`);
            }
            return response.json();
        })
        .then(data => console.log(data))
        .catch(error => {
            console.error('Fetch API 에러:', error.message);
            // 사용자에게 친화적인 에러 메시지 표시
            // showErrorToUser('데이터를 불러오는 데 실패했습니다.');
        });

    // async/await와 try...catch를 사용한 예외 처리
    async function fetchData() {
        try {
            const response = await fetch('https://api.example.com/invalid-url');
            if (!response.ok) {
                throw new Error(`HTTP 에러! 상태: ${response.status}`);
            }
            const data = await response.json();
            console.log(data);
        } catch (error) {
            console.error('데이터 로딩 중 에러 발생:', error.message);
            // 에러 로깅 서비스에 에러 정보 전송
            // logErrorToServer(error);
        }
    }
    ```

### 2.2. 사용자 정의 에러 (Custom Errors)
JavaScript의 내장 `Error` 객체를 확장하여 애플리케이션 특유의 에러를 정의할 수 있습니다. 이는 에러를 더 구체적으로 분류하고, 에러 처리 로직을 명확하게 만드는 데 도움이 됩니다.

- **구현 방법**: `Error` 클래스를 `extends`하여 새로운 에러 클래스를 생성합니다. `super()`를 호출하여 부모 `Error` 클래스의 생성자를 실행하고, `name` 속성을 설정하여 에러의 종류를 명확히 합니다.

**코드 사례:**
```javascript
class ValidationError extends Error {
    constructor(message) {
        super(message);
        this.name = "ValidationError";
    }
}

class NetworkError extends Error {
    constructor(message, statusCode) {
        super(message);
        this.name = "NetworkError";
        this.statusCode = statusCode;
    }
}

function validateInput(input) {
    if (input.length < 5) {
        throw new ValidationError("입력은 최소 5자 이상이어야 합니다.");
    }
    return true;
}

try {
    validateInput("abc");
} catch (e) {
    if (e instanceof ValidationError) {
        console.error(`유효성 검사 에러: ${e.message}`);
    } else {
        console.error(`알 수 없는 에러: ${e.message}`);
    }
}

async function fetchData() {
    try {
        const response = await fetch('https://api.example.com/data');
        if (!response.ok) {
            throw new NetworkError(`네트워크 요청 실패: ${response.status}`, response.status);
        }
        const data = await response.json();
        console.log(data);
    } catch (e) {
        if (e instanceof NetworkError) {
            console.error(`네트워크 에러 (${e.statusCode}): ${e.message}`);
        } else {
            console.error(`데이터 가져오기 에러: ${e.message}`);
        }
    }
}
fetchData();
```

### 2.3. 전역 에러 핸들링 (Global Error Handling)
애플리케이션 전체에서 발생하는 예상치 못한 에러를 중앙에서 처리하는 메커니즘입니다. 사용자 경험을 개선하고, 에러를 로깅하여 디버깅에 활용할 수 있습니다.

- **`window.onerror`**: 스크립트 실행 중 발생하는 에러를 잡는 전역 이벤트 핸들러입니다. 오래된 방식이지만, 모든 종류의 에러(특히 구문 에러)를 잡을 수 있습니다.

- **`window.addEventListener('error', ...)`**: `window.onerror`보다 더 현대적인 방식입니다. 에러 이벤트 객체를 통해 더 많은 정보를 얻을 수 있습니다. 이미지 로드 실패와 같은 리소스 로드 에러도 잡을 수 있습니다.

- **`window.addEventListener('unhandledrejection', ...)`**: 처리되지 않은 Promise 에러(reject 되었지만 `.catch()`로 잡히지 않은 에러)를 잡는 전역 이벤트 핸들러입니다. 비동기 코드에서 발생하는 에러를 처리하는 데 중요합니다.

**코드 사례:**
```javascript
// 스크립트 에러 처리
window.onerror = function(message, source, lineno, colno, error) {
    console.error("전역 에러 (onerror):", {
        message: message,
        source: source,
        lineno: lineno,
        colno: colno,
        error: error
    });
    // true를 반환하면 브라우저의 기본 에러 처리를 막습니다.
    return false;
};

// 리소스 로드 에러 및 스크립트 에러 처리 (더 권장)
window.addEventListener('error', function(event) {
    console.error("전역 에러 (addEventListener):", event);
    // 에러 정보를 서버로 전송하는 로직 (예: 에러 로깅 서비스)
    // sendErrorToServer(event);
});

// 처리되지 않은 Promise 에러 처리
window.addEventListener('unhandledrejection', function(event) {
    console.error("처리되지 않은 Promise 에러:", event.promise, event.reason);
    // 에러 정보를 서버로 전송하는 로직
    // sendErrorToServer(event.reason);
});

// 테스트를 위한 에러 발생
// throw new Error("일반적인 테스트 에러");
// Promise.reject("처리되지 않은 Promise 에러!");
// console.log(nonExistentVariable); // ReferenceError 발생

// 클라이언트 측 에러를 서버로 로깅하는 함수 (예시)
function sendErrorToServer(error) {
    fetch('/api/log-error', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
            message: error.message || error.reason, 
            stack: error.stack || (error.reason && error.reason.stack)
        })
    });
}
```

## 3. 기타 고급 주제 및 실무 기법

### 3.1. 정규 표현식 (Regular Expressions)

정규 표현식(Regular Expressions, RegExp)은 문자열에서 특정 패턴을 검색, 추출, 또는 대체하는 데 사용되는 강력한 도구입니다. 복잡한 문자열 처리 작업을 효율적으로 수행할 수 있게 해줍니다.

- **정규 표현식 생성**: 
    - **리터럴 방식**: `/pattern/flags` (가장 일반적)
    - **`RegExp` 생성자**: `new RegExp("pattern", "flags")`

- **플래그 (Flags)**:
    - `i` (ignore case): 대소문자를 구분하지 않고 검색합니다.
    - `g` (global): 패턴과 일치하는 모든 항목을 검색합니다 (첫 번째 일치 항목에서 멈추지 않음).
    - `m` (multiline): 다중 행 모드. `^`와 `$`가 각 줄의 시작/끝을 의미합니다.

- **주요 메서드**:
    - **`String.prototype.match()`**: 문자열에서 정규 표현식과 일치하는 부분을 배열로 반환합니다.
    - **`String.prototype.replace()`**: 문자열에서 정규 표현식과 일치하는 부분을 다른 문자열로 대체합니다.
    - **`RegExp.prototype.test()`**: 문자열이 정규 표현식 패턴과 일치하는지 여부를 `true` 또는 `false`로 반환합니다.
    - **`RegExp.prototype.exec()`**: 문자열에서 정규 표현식과 일치하는 부분을 검색하고, 일치하는 정보를 담은 배열을 반환합니다.

- **주요 패턴 요소**:
    - `.` : 모든 단일 문자 (줄바꿈 제외)
    - `*` : 0회 이상 반복
    - `+` : 1회 이상 반복
    - `?` : 0회 또는 1회 반복
    - `[]` : 문자 집합 중 하나 (예: `[abc]`는 'a', 'b', 'c' 중 하나)
    - `[^]` : 문자 집합을 제외한 문자 (예: `[^0-9]`는 숫자가 아닌 문자)
    - `()` : 그룹화
    - `|` : OR (예: `a|b`는 'a' 또는 'b')
    - `\d` : 숫자 (`[0-9]`와 동일)
    - `\D` : 숫자가 아닌 문자
    - `\w` : 알파벳, 숫자, 밑줄 (`[a-zA-Z0-9_]`와 동일)
    - `\W` : 알파벳, 숫자, 밑줄이 아닌 문자
    - `\s` : 공백 문자 (스페이스, 탭, 줄바꿈 등)
    - `\S` : 공백 문자가 아닌 문자
    - `^` : 문자열의 시작
    - `$` : 문자열의 끝

**코드 사례:**
```javascript
const text = "Hello 123 World 456";

// 숫자를 모두 찾기
const numbers = text.match(/\d+/g);
console.log(numbers); // ["123", "456"]

// "World"를 "JavaScript"로 대체
const newText = text.replace(/World/, "JavaScript");
console.log(newText); // "Hello 123 JavaScript 456"

// 이메일 형식 검사
const email = "test@example.com";
const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
console.log(emailRegex.test(email)); // true

const invalidEmail = "test@example";
console.log(emailRegex.test(invalidEmail)); // false
```


### 3.2. 메모리 관리 (Memory Management)
JavaScript는 가비지 컬렉션(Garbage Collection)을 통해 메모리를 자동으로 관리하지만, 개발자의 실수로 인해 메모리 누수(Memory Leak)가 발생할 수 있습니다. 메모리 누수는 애플리케이션의 성능 저하와 충돌로 이어질 수 있으므로 이해하고 관리하는 것이 중요합니다.

- **가비지 컬렉션 (Garbage Collection)**: JavaScript 엔진은 더 이상 접근할 수 없는(참조되지 않는) 객체를 자동으로 메모리에서 해제합니다. 이를 통해 개발자가 수동으로 메모리를 관리할 필요가 없습니다.

- **흔한 메모리 누수 패턴**:
    - **전역 변수**: 의도치 않게 전역 변수를 생성하거나, 전역 객체에 불필요한 참조를 유지하는 경우.
    - **클로저 (Closures)**: 클로저가 외부 스코프의 변수를 참조하고 있을 때, 클로저 함수가 더 이상 사용되지 않더라도 외부 변수가 해제되지 않아 메모리에 남아있을 수 있습니다. 특히 DOM 요소를 참조하는 클로저에 주의해야 합니다.
    - **타이머 (Timers)**: `setTimeout`이나 `setInterval`의 콜백 함수 내에서 외부 변수나 DOM 요소를 참조하고, 타이머가 명시적으로 해제되지 않으면 메모리 누수가 발생할 수 있습니다.
    - **이벤트 리스너 (Event Listeners)**: DOM 요소에 이벤트 리스너를 등록한 후, 해당 DOM 요소가 제거될 때 리스너를 함께 제거하지 않으면 메모리에 남아있을 수 있습니다. 특히 `addEventListener`로 등록한 리스너는 `removeEventListener`로 명시적으로 제거해야 합니다.
    - **DOM 외부 참조**: JavaScript 코드에서 DOM 요소를 참조하고 있는데, 해당 DOM 요소가 HTML에서 제거되더라도 JavaScript에서 참조를 끊지 않으면 메모리에 남아있을 수 있습니다.

- **메모리 누수 디버깅 도구**: 크롬 개발자 도구의 'Performance' 탭이나 'Memory' 탭을 사용하여 메모리 사용량을 모니터링하고, 힙 스냅샷(Heap Snapshot)을 분석하여 메모리 누수의 원인을 찾을 수 있습니다.

**코드 사례 (메모리 누수 예방 - 이벤트 리스너):**
```javascript
const button = document.getElementById('myButton');

function handleClick() {
  console.log('버튼 클릭!');
}

button.addEventListener('click', handleClick);

// 버튼이 DOM에서 제거될 때 이벤트 리스너도 함께 제거
// 예를 들어, 페이지 전환 시 또는 컴포넌트 언마운트 시
// button.removeEventListener('click', handleClick);
```

**코드 사례 (메모리 누수 예방 - 타이머):**
```javascript
let intervalId;

function startInterval() {
  let count = 0;
  intervalId = setInterval(() => {
    console.log(count++);
    if (count > 5) {
      clearInterval(intervalId); // 타이머 명시적으로 해제
    }
  }, 1000);
}

// startInterval();
```

### 3.3. 성능 최적화 패턴 (Debouncing & Throttling)
웹 애플리케이션에서 사용자 입력, 스크롤 이벤트, 창 크기 조절 등 빈번하게 발생하는 이벤트는 성능 저하를 유발할 수 있습니다. 이를 방지하기 위해 디바운싱(Debouncing)과 스로틀링(Throttling)과 같은 패턴을 사용하여 이벤트 핸들러의 실행 빈도를 제어합니다.

- **디바운싱 (Debouncing)**: 특정 이벤트가 연속적으로 발생할 때, 마지막 이벤트가 발생한 후 일정 시간(딜레이)이 지나야만 콜백 함수를 실행합니다. 주로 검색창 입력, 창 크기 조절 등 '마지막' 동작에만 반응해야 할 때 사용됩니다.

    **코드 사례 (디바운싱):**
    ```javascript
    function debounce(func, delay) {
      let timeout;
      return function(...args) {
        const context = this;
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(context, args), delay);
      };
    }

    const handleSearchInput = debounce((event) => {
      console.log('검색어:', event.target.value);
    }, 500); // 0.5초 동안 입력이 없으면 실행

    // 예시: <input type="text" onkeyup="handleSearchInput(event)">
    ```

- **스로틀링 (Throttling)**: 특정 이벤트가 발생할 때, 일정 시간(딜레이) 동안 콜백 함수가 최대 한 번만 실행되도록 제한합니다. 주로 스크롤 이벤트, 버튼 연타 방지 등 '일정 주기'로 동작해야 할 때 사용됩니다.

    **코드 사례 (스로틀링):**
    ```javascript
    function throttle(func, delay) {
      let waiting = false;
      return function(...args) {
        if (!waiting) {
          func.apply(this, args);
          waiting = true;
          setTimeout(() => {
            waiting = false;
          }, delay);
        }
      };
    }

    const handleScroll = throttle(() => {
      console.log('스크롤 이벤트 발생!');
    }, 100); // 0.1초에 한 번만 실행

    // 예시: window.addEventListener('scroll', handleScroll);
    ```

### 3.4. 함수형 프로그래밍 (Functional Programming)
JavaScript는 다중 패러다임 언어이지만, 함수형 프로그래밍(Functional Programming) 스타일을 강력하게 지원합니다. 함수형 프로그래밍은 프로그램을 '상태 변경'과 '가변 데이터' 대신 '순수 함수'와 '불변성'을 중심으로 구축하는 프로그래밍 패러다임입니다.

- **순수 함수 (Pure Functions)**:
    - **동일한 입력에 대해 항상 동일한 출력**을 반환합니다.
    - **외부 상태를 변경하지 않습니다 (부수 효과 없음)**. 즉, 함수 외부의 변수나 객체를 수정하지 않습니다.
    - **장점**: 예측 가능하고, 테스트하기 쉬우며, 병렬 처리에 안전합니다.

    **코드 사례 (순수 함수):**
    ```javascript
    // 순수 함수: 입력값에만 의존하고 외부 상태를 변경하지 않음
    function addPure(a, b) {
      return a + b;
    }

    let total = 0;
    // 비순수 함수: 외부 변수(total)를 변경하는 부수 효과가 있음
    function addImpure(a, b) {
      total = a + b; // 외부 상태 변경
      return total;
    }
    ```

- **불변성 (Immutability)**:
    - 데이터가 생성된 후에는 **변경되지 않는** 특성을 의미합니다. 데이터가 변경될 필요가 있을 때는 원본 데이터를 수정하는 대신, 변경된 내용을 포함하는 새로운 데이터를 생성합니다.
    - JavaScript에서 원시 타입(숫자, 문자열, 불리언 등)은 기본적으로 불변하지만, 객체와 배열은 가변(mutable)합니다.
    - **불변성을 유지하는 방법**:
        - 배열: `map()`, `filter()`, `reduce()`, `slice()`, 전개 구문(`...`) 등을 사용하여 새로운 배열을 생성합니다.
        - 객체: `Object.assign()`, 전개 구문(`...`) 등을 사용하여 새로운 객체를 생성합니다.
    - **장점**: 데이터 추적 및 디버깅이 용이하고, 예상치 못한 부수 효과를 방지하며, React/Redux와 같은 상태 관리 라이브러리에서 상태 변경을 효율적으로 감지하는 데 필수적입니다.

    **코드 사례 (불변성):**
    ```javascript
    // 배열 불변성 유지
    const originalArray = [1, 2, 3];
    const newArray = [...originalArray, 4]; // 새로운 배열 생성
    console.log(originalArray); // [1, 2, 3] (원본 유지)
    console.log(newArray);      // [1, 2, 3, 4]

    // 객체 불변성 유지
    const originalUser = { name: 'Alice', age: 30 };
    const updatedUser = { ...originalUser, age: 31 }; // 새로운 객체 생성
    console.log(originalUser); // { name: 'Alice', age: 30 } (원본 유지)
    console.log(updatedUser);  // { name: 'Alice', age: 31 }
    ```
