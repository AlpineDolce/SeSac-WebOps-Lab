<h2>JavaScript 개요 및 기본 문법</h2>
작성자: Alpine_Dolce&nbsp;&nbsp;|&nbsp;&nbsp;날짜: 2025-07-04

<h2>문서 목표</h2>
<p>이 문서는 JavaScript의 핵심 문법과 주요 개념을 체계적으로 정리하여, 동적인 웹 페이지를 개발하는 능력을 기르는 것을 목표로 합니다. 변수 선언, 함수, 객체, 비동기 처리 등 필수 개념들을 상세한 코드 예제와 함께 학습하여 실무 활용도를 높이고자 합니다.</p>

<h2>목차</h2>

- [1. JavaScript 개요 및 기본 문법](#1-javascript-개요-및-기본-문법)
  - [1.1. JavaScript란?](#11-javascript란)
  - [1.2 변수 선언: `var`, `let`, `const`와 호이스팅](#12-변수-선언-var-let-const와-호이스팅)
  - [1.3. 데이터 타입 (Data Types)](#13-데이터-타입-data-types)
    - [주요 데이터 타입](#주요-데이터-타입)
  - [1.4. 연산자 (Operators)](#14-연산자-operators)
    - [주요 연산자](#주요-연산자)
  - [1.5. 조건문 (Conditional Statements)](#15-조건문-conditional-statements)
    - [1.5.1. `if...else if...else`](#151-ifelse-ifelse)
    - [1.5.2. `switch`](#152-switch)
    - [1.5.3. Truthy와 Falsy](#153-truthy와-falsy)
  - [1.6. 반복문 (Loops)](#16-반복문-loops)
    - [1.6.1. `for` 루프](#161-for-루프)
    - [1.6.2. `for...in` 루프](#162-forin-루프)
    - [1.6.3. `for...of` 루프](#163-forof-루프)
    - [1.6.4. `forEach()` 루프](#164-foreach-루프)
  - [1.7. `this` 키워드](#17-this-키워드)
  - [1.8. 엄격 모드 (`'use strict'`)](#18-엄격-모드-use-strict)
  - [1.9. 타입 강제 변환 (Type Coercion)](#19-타입-강제-변환-type-coercion)
  - [1.10. ES6+ 주요 문법](#110-es6-주요-문법)
    - [1.10.1. 구조 분해 할당 (Destructuring Assignment)](#1101-구조-분해-할당-destructuring-assignment)
    - [1.10.2. 전개/나머지 문법 (Spread/Rest Syntax)](#1102-전개나머지-문법-spreadrest-syntax)
    - [1.10.3. 템플릿 리터럴 (Template Literals)](#1103-템플릿-리터럴-template-literals)
    - [1.10.4. Optional Chaining (`?.`) 및 Nullish Coalescing (`??`)](#1104-optional-chaining--및-nullish-coalescing-)
    - [1.10.5. `Set` 및 `Map`](#1105-set-및-map)

---

## 1. JavaScript 개요 및 기본 문법

### 1.1. JavaScript란?
JavaScript는 웹 페이지에 동적인 기능을 부여하기 위해 만들어진 **객체 기반의 스크립트 프로그래밍 언어**입니다. HTML(웹 페이지의 구조)과 CSS(웹 페이지의 스타일)와 함께 웹을 구성하는 핵심 기술 중 하나입니다. 초기에는 주로 웹 브라우저에서 클라이언트 사이드 스크립팅에 사용되었지만, Node.js의 등장으로 서버 사이드 개발, 모바일 앱(React Native), 데스크톱 앱(Electron) 등 다양한 분야에서 활용되는 **풀스택 언어**로 발전했습니다.

- **주요 특징**:
    - **인터프리터 언어**: 코드가 컴파일 과정 없이 바로 실행됩니다.
    - **동적 타입 (Dynamically Typed)**: 변수의 타입이 런타임에 결정되며, 같은 변수에 여러 타입의 값을 할당할 수 있습니다.
    - **싱글 스레드 (Single-threaded)**: 한 번에 하나의 작업만 처리하지만, 비동기 처리 모델을 통해 동시성(Concurrency)을 지원합니다.
    - **멀티 패러다임**: 객체 지향, 함수형, 절차 지향 프로그래밍 스타일을 모두 지원합니다.
    - **크로스 플랫폼**: 브라우저, 서버, 모바일 등 다양한 환경에서 실행될 수 있습니다.

**풀스택 관점**: JavaScript는 프론트엔드(React, Vue, Angular 등)와 백엔드(Node.js, Express 등) 모두에서 사용될 수 있어, 풀스택 개발자가 하나의 언어로 전체 애플리케이션을 구축할 수 있게 해주는 강력한 도구입니다. 이는 개발 생산성을 높이고, 팀 내 기술 스택의 통일성을 가져올 수 있습니다.


### 1.2 변수 선언: `var`, `let`, `const`와 호이스팅

JavaScript에서 변수를 선언하는 방식은 `var`, `let`, `const`가 있습니다. ES6 이전에는 `var`만 사용되었지만, 현재는 `let`과 `const`의 사용이 권장됩니다.

- **`var`**: 함수 스코프(function-scope)를 가집니다. 변수 선언이 코드의 최상단으로 끌어올려지는 **호이스팅(Hoisting)** 현상이 발생하며, 이로 인해 코드 블록(`{...}`) 안에서 선언해도 블록 밖에서 접근 가능하여 예측하기 어려운 문제를 일으킬 수 있습니다.

    **코드 사례 (`let과var차이점.js`):
    ```javascript
    // var는 호이스팅으로 인해 선언 전에 사용해도 에러가 발생하지 않습니다.
    // 또한, 블록 스코프를 무시합니다.
    msg = "hello";
    if (true) { 
        var msg = "안녕하세요"; // 이 선언이 최상단으로 끌어올려짐
    }
    console.log(msg); // 출력: 안녕하세요 (if 블록 안의 값이 밖의 변수에 영향을 줌)
    ```

- **`let`**: 블록 스코프(block-scope)를 가집니다. 즉, 변수가 선언된 코드 블록(`{...}`) 안에서만 유효합니다. 호이스팅이 발생하지 않는 것처럼 동작하여, `var`의 단점을 보완하고 코드의 예측 가능성을 높여줍니다.

- **`const`**: `let`과 같이 블록 스코프를 가지지만, **상수(constant)**를 선언할 때 사용됩니다. 즉, 한 번 값을 할당하면 재할당할 수 없습니다. 객체나 배열을 `const`로 선언할 경우, 객체의 속성이나 배열의 요소는 변경할 수 있습니다.

### 1.3. 데이터 타입 (Data Types)

JavaScript는 동적 타입을 가진 언어로, 변수의 타입이 실행 시점에 결정됩니다. 주요 데이터 타입과 연산자는 다음과 같습니다.

#### 주요 데이터 타입
- **원시 타입 (Primitive Types)**
    - **`String`**: 텍스트 데이터를 나타냅니다. (예: `"hello"`, `'world'`)
    - **`Number`**: 정수와 실수를 모두 포함하는 숫자 데이터입니다. (예: `10`, `3.14`)
    - **`Boolean`**: `true` 또는 `false` 값을 가집니다.
    - **`null`**: '값이 없음'을 의도적으로 명시할 때 사용되는 값입니다.
    - **`undefined`**: 변수를 선언하고 값을 할당하지 않았을 때의 기본값입니다.
    - **`Symbol`**: ES6에서 추가된, 유일하고 변경 불가능한 원시 값입니다. 주로 객체 속성의 키로 사용됩니다.
- **객체 타입 (Object Type)**
    - **`Object`**: 키와 값의 쌍으로 이루어진 데이터의 집합입니다. (배열, 함수, 정규표현식 등을 모두 포함)

### 1.4. 연산자 (Operators)

#### 주요 연산자
- **산술 연산자**: `+`, `-`, `*`, `/`, `%` (나머지), `**` (거듭제곱)
- **할당 연산자**: `=`, `+=`, `-=`, `*=`, `/=`
- **비교 연산자**: 
    - `==` (동등 연산자): 타입을 변환하여 값을 비교합니다. (예: `"1" == 1` -> `true`)
    - `===` (일치 연산자): 타입과 값을 모두 비교합니다. **(사용 권장)** (예: `"1" === 1` -> `false`)
    - `!=`, `!==`, `>`, `<`, `>=`, `<=`
- **논리 연산자**: `&&` (AND), `||` (OR), `!` (NOT)
- **증감 연산자**: `++` (1 증가), `--` (1 감소)
    - **전치 (`++a`)**: 먼저 값을 증가시킨 후 다른 연산을 수행합니다.
    - **후치 (`a++`)**: 다른 연산을 먼저 수행한 후 값을 증가시킵니다.

    **코드 사례 (`for1.js`):
    ```javascript
    let a = 5;
    let b = ++a; // a를 6으로 만들고, 그 값을 b에 할당
    console.log(`a=${a}, b=${b}`); // a=6, b=6

    a = 5;
    b = a++; // a의 값(5)를 b에 먼저 할당하고, 그 다음 a를 6으로 만듦
    console.log(`a=${a}, b=${b}`); // a=6, b=5
    ```
### 1.5. 조건문 (Conditional Statements)

조건문은 주어진 조건식의 평가 결과(true 또는 false)에 따라 다른 코드 블록을 실행하도록 제어하는 구문입니다.

#### 1.5.1. `if...else if...else`
- **`if...else if...else`**: 가장 기본적인 조건문입니다.
    - `if` 블록은 조건식이 `true`일 때 실행됩니다.
    - `else if` 블록은 이전 `if` 또는 `else if` 조건이 `false`일 때, 자신의 조건식을 평가하여 `true`이면 실행됩니다. (여러 개 사용 가능)
    - `else` 블록은 앞의 모든 조건식이 `false`일 때 실행됩니다. (선택 사항)

    **코드 사례:**
    ```javascript
    const score = 85;

    if (score >= 90) {
        console.log("A 등급");
    } else if (score >= 80) {
        console.log("B 등급"); // 이 블록이 실행됨
    } else {
        console.log("C 등급 이하");
    }
    ```

#### 1.5.2. `switch`
- **`switch`**: 하나의 표현식을 여러 값과 비교하여 일치하는 경우에 해당하는 코드 블록을 실행합니다. `if...else if`가 여러 번 반복될 때 더 간결하게 표현할 수 있습니다.
    - `case` 문으로 특정 값과 비교합니다.
    - `break` 문을 사용하여 해당 `case`의 코드 실행 후 `switch` 문을 빠져나옵니다. `break`가 없으면 다음 `case`가 연달아 실행되므로 주의해야 합니다.
    - `default` 문은 어떤 `case`와도 일치하지 않을 때 실행됩니다.

    **코드 사례:**
    ```javascript
    const fruit = "Banana";

    switch (fruit) {
        case "Apple":
            console.log("사과입니다.");
            break;
        case "Banana":
            console.log("바나나입니다."); // 이 블록이 실행됨
            break;
        case "Orange":
            console.log("오렌지입니다.");
            break;
        default:
            console.log("목록에 없는 과일입니다.");
    }
    ```

#### 1.5.3. Truthy와 Falsy
- **Truthy와 Falsy**: JavaScript에서는 `Boolean` 값이 아니더라도 조건식에서 `true` 또는 `false`로 평가되는 값들이 있습니다.
    - **Falsy 값**: `false`, `0`, `""` (빈 문자열), `null`, `undefined`, `NaN`. 이 값들은 조건문에서 `false`로 취급됩니다.
    - **Truthy 값**: Falsy 값을 제외한 모든 값. (예: `true`, `1`, `"hello"`, `[]`, `{}`) 이 값들은 조건문에서 `true`로 취급됩니다.

    **코드 사례:**
    ```javascript
    let username = "";
    if (username) {
        console.log(`안녕하세요, ${username}님!`);
    } else {
        console.log("사용자 이름이 없습니다."); // 빈 문자열은 Falsy이므로 이 블록이 실행됨
    }
    ```

### 1.6. 반복문 (Loops)

배열이나 객체의 요소를 순회하며 반복적인 작업을 수행할 때 사용됩니다.

#### 1.6.1. `for` 루프
- **`for` 루프**: 가장 기본적인 반복문으로, 초기값, 조건식, 증감치를 이용하여 반복을 제어합니다.

    **코드 사례 (`for1.js`):
    ```javascript
    // 1부터 10까지 출력
    console.log("1~10까지 출력하기");
    for(let i = 1; i <= 10; i++) {
        console.log(`i=${i}`);
    }

    // 배열 순회
    let arr = [1, 2, 3, 4, 5];
    for(let i = 0; i < arr.length; i++) {
        console.log(arr[i]);
    }
    ```

#### 1.6.2. `for...in` 루프
- **`for...in` 루프**: 객체의 **키(key) 또는 배열의 인덱스(index)**를 순회합니다.

    **코드 사례 (`for1.js`, `for2.js`):
    ```javascript
    let arr = [10, 20, 30, 40, 50];
    for(let i in arr){
        // i는 문자열 형태의 인덱스 '0', '1', '2', ...
        console.log(`index=${i}, value=${arr[i]}`);
    }

    let person = { name: "홍길동", age: 23, phone: '010-0000-0001' };
    for(let key in person) {
        console.log(`${key}: ${person[key]}`);
    }
    ```

#### 1.6.3. `for...of` 루프
- **`for...of` 루프**: 배열, 문자열 등 **반복 가능한(iterable) 객체**의 **값(value)**을 직접 순회합니다. `for...in`보다 직관적이고 사용하기 편리합니다.

    **코드 사례 (`for1.js`, `for2.js`):
    ```javascript
    let words = ["rain", "umbrella", "desk"];
    for(let word of words){
        console.log(word); // 출력: rain, umbrella, desk
    }
    ```

#### 1.6.4. `forEach()` 루프
- **`forEach()` 메서드**: 배열이 가진 내장 메서드로, 각 요소에 대해 주어진 함수(콜백 함수)를 실행합니다.

    **코드 사례 (`for2.js`):
    ```javascript
    let persons = [
        { name: "홍길동", phone: "010-0000-0001" },
        { name: "임꺽정", phone: "010-0000-0002" }
    ];

    persons.forEach(p => {
        console.log(`${p.name} / ${p.phone}`);
    });
    ```

### 1.7. `this` 키워드

`this`는 함수가 **어떻게 호출되었는지**에 따라 가리키는 값이 동적으로 결정되는 특별한 키워드입니다.

- **전역 컨텍스트**: 함수 외부에서 `this`는 전역 객체(브라우저에서는 `window`)를 가리킵니다.
- **함수 호출**: 일반 함수로 호출될 때 `this`는 전역 객체를 가리킵니다. (`strict mode`에서는 `undefined`)
- **메서드 호출**: 객체의 메서드로서 함수가 호출될 때, `this`는 해당 **객체**를 가리킵니다.
- **생성자 함수 호출**: `new` 키워드로 함수를 호출할 때, `this`는 새로 생성되는 객체를 가리킵니다.
- **화살표 함수**: 자신만의 `this`를 갖지 않고, 자신을 감싸는 **상위 스코프의 `this`**를 그대로 물려받습니다.

### 1.8. 엄격 모드 (`'use strict'`)
JavaScript의 엄격 모드(Strict Mode)는 코드의 잠재적인 오류를 줄이고 안전하게 작성하기 위한 기능입니다. 스크립트나 함수의 시작 부분에 `'use strict'`를 선언하여 활성화할 수 있습니다.

- **주요 특징**: 
    - 암묵적 전역 변수 선언 금지 (선언되지 않은 변수에 값 할당 시 에러 발생)
    - `this` 키워드의 동작 변경 (일반 함수 호출 시 `this`가 `undefined`가 됨)
    - `delete` 연산자로 변수, 함수, 인자 삭제 금지
    - 중복된 매개변수 이름 금지
    - `with` 문 사용 금지

**코드 사례:**
```javascript
'use strict';

// var x = 10; // 정상
// y = 20; // ReferenceError: y is not defined (엄격 모드에서는 에러 발생)

function testStrict() {
  // 'use strict'; // 함수 내에서 선언 가능
  // console.log(this); // undefined (일반 함수 호출 시)
}
testStrict();
```

### 1.9. 타입 강제 변환 (Type Coercion)
JavaScript는 동적 타입 언어이므로, 필요에 따라 값의 타입을 자동으로 변환하는 **타입 강제 변환(Type Coercion)**이 발생합니다. 이는 편리할 수도 있지만, 예상치 못한 버그의 원인이 될 수 있습니다.

- **암묵적 강제 변환**: 연산자나 문맥에 의해 JavaScript 엔진이 자동으로 타입을 변환하는 경우입니다.
    - 숫자와 문자열 연산: `1 + '2'`는 `'12'` (문자열 연결)
    - 비교 연산자 (`==`): `true == 1`은 `true`
    - 논리 연산자: Truthy/Falsy 값 평가
- **명시적 강제 변환**: 개발자가 의도적으로 `Number()`, `String()`, `Boolean()` 등의 함수를 사용하여 타입을 변환하는 경우입니다。

**코드 사례:**
```javascript
// 암묵적 강제 변환
console.log(1 + '2');     // "12" (숫자 1이 문자열 "1"로 변환)
console.log('5' - 2);     // 3 (문자열 "5"가 숫자 5로 변환)
console.log(true == 1);   // true (true가 숫자 1로 변환)
console.log(false == 0);  // true (false가 숫자 0으로 변환)

// 명시적 강제 변환
console.log(Number('123'));   // 123
console.log(String(123));     // "123"
console.log(Boolean(0));      // false
console.log(Boolean('hello'));// true
```

### 1.10. ES6+ 주요 문법

ES6(ECMAScript 2015) 이후 도입된 문법들은 JavaScript 개발의 편의성과 코드 가독성을 크게 향상시켰습니다.

#### 1.10.1. 구조 분해 할당 (Destructuring Assignment)
- **구조 분해 할당 (Destructuring Assignment)**: 배열이나 객체의 속성을 분해하여 그 값을 개별 변수에 쉽게 할당할 수 있게 해줍니다.

    **코드 사례:**
    ```javascript
    // 객체 구조 분해
    const user = { name: "홍길동", age: 25, email: "hong@example.com" };
    const { name, age } = user;
    console.log(name); // "홍길동"
    console.log(age);  // 25

    // 배열 구조 분해
    const [first, second] = [1, 2, 3, 4];
    console.log(first);  // 1
    console.log(second); // 2
    ```

#### 1.10.2. 전개/나머지 문법 (Spread/Rest Syntax)
- **전개/나머지 문법 (Spread/Rest Syntax)**: `...` 기호를 사용하여 배열이나 객체를 확장하거나, 여러 개의 인자를 하나로 묶습니다.
    - **전개(Spread)**: 배열이나 객체의 모든 요소를 개별적으로 펼쳐줍니다. 배열 복사, 객체 병합 등에 유용합니다.
    - **나머지(Rest)**: 함수의 매개변수에서 정해지지 않은 수의 인자들을 배열로 모읍니다.

    **코드 사례:**
    ```javascript
    // 전개 문법 (배열)
    const arr1 = [1, 2, 3];
    const arr2 = [...arr1, 4, 5]; // [1, 2, 3, 4, 5]

    // 나머지 문법
    function sum(...numbers) {
      return numbers.reduce((acc, current) => acc + current, 0);
    }
    console.log(sum(1, 2, 3, 4)); // 10
    ```

#### 1.10.3. 템플릿 리터럴 (Template Literals)
- **템플릿 리터럴 (Template Literals)**: 백틱(``` `` ```)을 사용하여 문자열을 정의합니다. `${...}`를 통해 문자열 안에 변수나 표현식을 쉽게 삽입할 수 있습니다.

#### 1.10.4. Optional Chaining (`?.`) 및 Nullish Coalescing (`??`)
- **Optional Chaining (`?.`) 및 Nullish Coalescing (`??`)**: 현대 JavaScript에서 객체 속성에 안전하게 접근하고 기본값을 설정하는 데 매우 유용하게 사용됩니다.
    - **Optional Chaining (`?.`)**: 속성이 `null` 또는 `undefined`인 경우 에러를 발생시키지 않고 `undefined`를 반환합니다. 중첩된 객체에 접근할 때 유용합니다.
    - **Nullish Coalescing (`??`)**: 왼쪽 피연산자가 `null` 또는 `undefined`일 때 오른쪽 피연산자를 반환하고, 그렇지 않으면 왼쪽 피연산자를 반환합니다. `||` 연산자와 유사하지만, `0`이나 `''` (빈 문자열)과 같은 falsy 값을 `true`로 취급합니다.

    **코드 사례:**
    ```javascript
    const user = {
      name: "Alice",
      address: {
        street: "123 Main St"
      }
    };

    console.log(user.address?.street); // "123 Main St"
    console.log(user.contact?.email); // undefined (에러 발생 안 함)

    const value = null;
    const defaultValue = value ?? "기본값"; // "기본값"
    const zero = 0;
    const result = zero ?? 100; // 0 (??는 0을 falsy로 취급하지 않음)
    console.log(defaultValue, result);
    ```

#### 1.10.5. `Set` 및 `Map`
- **`Set` 및 `Map`**: 배열과 객체 외에 자주 사용되는 유용한 데이터 구조입니다.

    - **`Set`**: 중복되지 않는 유일한 값들의 컬렉션입니다. 값의 추가, 삭제, 존재 여부 확인에 최적화되어 있습니다.
        - `new Set()`: 새로운 Set 객체를 생성합니다.
        - `add(value)`: Set에 값을 추가합니다.
        - `delete(value)`: Set에서 값을 삭제합니다.
        - `has(value)`: Set에 값이 존재하는지 확인합니다.
        - `size`: Set의 요소 개수를 반환합니다.

    **코드 사례:**
    ```javascript
    const uniqueNumbers = new Set();
    uniqueNumbers.add(1);
    uniqueNumbers.add(2);
    uniqueNumbers.add(1); // 중복되므로 추가되지 않음
    console.log(uniqueNumbers); // Set(2) {1, 2}
    console.log(uniqueNumbers.has(2)); // true
    ```

    - **`Map`**: 키-값 쌍을 저장하는 컬렉션입니다. 객체와 유사하지만, 키로 모든 데이터 타입(객체, 함수 등)을 사용할 수 있으며, 삽입 순서를 유지합니다.
        - `new Map()`: 새로운 Map 객체를 생성합니다.
        - `set(key, value)`: Map에 키-값 쌍을 추가합니다.
        - `get(key)`: Map에서 키에 해당하는 값을 반환합니다.
        - `delete(key)`: Map에서 키-값 쌍을 삭제합니다.
        - `has(key)`: Map에 키가 존재하는지 확인합니다.
        - `size`: Map의 요소 개수를 반환합니다.

    **코드 사례:**
    ```javascript
    const userRoles = new Map();
    userRoles.set('alice', 'admin');
    userRoles.set('bob', 'editor');
    console.log(userRoles.get('alice')); // "admin"
    console.log(userRoles.has('charlie')); // false
    ```