<h2>비동기 JavaScript 및 웹 통신</h2>
작성자: Alpine_Dolce&nbsp;&nbsp;|&nbsp;&nbsp;날짜: 2025-07-04

<h2>문서 목표</h2>
<p>이 문서는 JavaScript의 핵심 문법과 주요 개념을 체계적으로 정리하여, 동적인 웹 페이지를 개발하는 능력을 기르는 것을 목표로 합니다. 변수 선언, 함수, 객체, 비동기 처리 등 필수 개념들을 상세한 코드 예제와 함께 학습하여 실무 활용도를 높이고자 합니다.</p>

<h2>목차</h2>

- [3. 비동기 JavaScript 및 웹 통신](#3-비동기-javascript-및-웹-통신)
  - [3.1. 비동기 처리 개요 (동기 vs 비동기, 실행 컨텍스트, 이벤트 루프)](#31-비동기-처리-개요-동기-vs-비동기-실행-컨텍스트-이벤트-루프)
  - [3.2. `Promise`](#32-promise)
  - [3.3. `async/await`](#33-asyncawait)
  - [3.4. Fetch API 또는 Axios](#34-fetch-api-또는-axios)
  - [3.5. WebSockets](#35-websockets)
  - [3.6. JavaScript 런타임 환경 (브라우저 vs Node.js)](#36-javascript-런타임-환경-브라우저-vs-nodejs)

---

## 3. 비동기 JavaScript 및 웹 통신

### 3.1. 비동기 처리 개요 (동기 vs 비동기, 실행 컨텍스트, 이벤트 루프)

JavaScript는 기본적으로 **싱글 스레드(Single-threaded)** 기반으로 동작합니다. 이는 한 번에 하나의 작업만 처리할 수 있다는 의미입니다. 하지만 웹 환경에서는 네트워크 요청, 타이머, 사용자 이벤트 등 시간이 오래 걸리거나 즉시 응답할 수 없는 작업들이 많습니다. 이러한 작업들이 메인 스레드를 블로킹하여 UI가 멈추는 것을 방지하기 위해 JavaScript는 **비동기 처리** 모델을 지원합니다.

- **동기(Synchronous) 방식**: 코드가 작성된 순서대로 위에서 아래로, 왼쪽에서 오른쪽으로 하나씩 실행됩니다. 하나의 작업이 완료될 때까지 다음 작업은 대기해야 합니다. 작업이 길어지면 전체 프로그램이 멈추는 **블로킹(Blocking)** 현상이 발생합니다.

    **코드 사례 (`동기식2.js`):
    ```javascript
    const fs = require('fs');
    try {
        // readFileSync는 파일 읽기가 끝날 때까지 다음 코드로 넘어가지 않습니다.
        const data = fs.readFileSync('./동기식1.js', 'utf-8');
        console.log(data);
    }
    catch(e) {
        console.log(e);
    }
    console.log("completed"); // 파일 읽기가 모두 끝난 후에 실행됨
    ```

- **비동기(Asynchronous) 방식**: 시간이 오래 걸리는 작업을 메인 스레드에서 분리하여 백그라운드에서 처리하도록 위임하고, 즉시 다음 코드를 실행합니다. 작업이 완료되면 미리 등록해 둔 콜백 함수를 통해 결과를 받습니다. 이는 **논블로킹(Non-blocking)** 방식으로 동작하여 사용자 경험을 향상시킵니다.

- **실행 컨텍스트 (Execution Context)**: JavaScript 코드가 실행되는 환경을 의미합니다. 코드가 실행될 때마다 생성되며, 변수, 함수 선언, `this` 값 등을 포함합니다. JavaScript 엔진은 콜 스택(Call Stack)에 실행 컨텍스트를 쌓아가며 코드를 실행합니다.

- **콜 스택 (Call Stack)**: JavaScript 엔진이 함수 호출을 추적하는 LIFO(Last In, First Out) 구조의 스택입니다. 함수가 호출되면 스택에 쌓이고, 함수 실행이 완료되면 스택에서 제거됩니다. 동기적인 작업은 모두 콜 스택에서 처리됩니다.

- **이벤트 루프 (Event Loop)**: JavaScript의 비동기 처리의 핵심 메커니즘입니다. 콜 스택이 비어 있을 때, 태스크 큐(Task Queue)에 있는 비동기 작업의 콜백 함수를 콜 스택으로 옮겨 실행되도록 합니다. 이를 통해 싱글 스레드인 JavaScript가 비동기 작업을 효율적으로 처리할 수 있습니다.

    **이벤트 루프의 주요 구성 요소**:
    - **콜 스택 (Call Stack)**: 현재 실행 중인 함수를 추적합니다.
    - **힙 (Heap)**: 객체가 저장되는 메모리 공간입니다.
    - **Web API (브라우저 환경)**: 브라우저에서 제공하는 비동기 작업을 위한 API (예: `setTimeout`, `fetch`, DOM 이벤트 리스너). 이들은 JavaScript 엔진 외부에 존재합니다.
    - **태스크 큐 (Task Queue / Callback Queue)**: Web API에서 완료된 비동기 작업의 콜백 함수들이 대기하는 큐입니다. (매크로태스크 큐)
    - **마이크로태스크 큐 (Microtask Queue)**: `Promise`의 `.then()`, `.catch()`, `finally()` 콜백이나 `MutationObserver` 콜백 등이 대기하는 큐입니다. 태스크 큐보다 우선순위가 높습니다.

    **동작 과정**: 
    1. 모든 동기 코드는 콜 스택에서 실행됩니다.
    2. 비동기 작업(예: `setTimeout`, `fetch`)이 호출되면, 해당 작업은 Web API로 위임되고 콜 스택에서는 즉시 제거됩니다.
    3. Web API에서 비동기 작업이 완료되면, 해당 작업의 콜백 함수가 태스크 큐(또는 마이크로태스크 큐)로 이동합니다.
    4. 이벤트 루프는 콜 스택이 비어 있는지 계속 확인합니다.
    5. 콜 스택이 비어 있으면, 이벤트 루프는 마이크로태스크 큐의 모든 작업을 콜 스택으로 옮겨 실행하고, 마이크로태스크 큐가 비면 태스크 큐의 첫 번째 작업을 콜 스택으로 옮겨 실행합니다.

    **코드 사례 (이벤트 루프 동작 이해):**
    ```javascript
    console.log('1. 동기 작업 시작');

    setTimeout(() => {
      console.log('3. setTimeout 콜백 (태스크 큐)');
    }, 0); // 0ms 지연이지만, Web API로 위임되므로 비동기

    Promise.resolve().then(() => {
      console.log('2. Promise 콜백 (마이크로태스크 큐)');
    });

    console.log('4. 동기 작업 종료');

    // 출력 순서: 
    // 1. 동기 작업 시작
    // 4. 동기 작업 종료
    // 2. Promise 콜백 (마이크로태스크 큐가 태스크 큐보다 우선)
    // 3. setTimeout 콜백 (태스크 큐)
    ```

- **비동기(Asynchronous) 방식과 콜백**: 작업이 완료되기를 기다리지 않고 즉시 다음 코드를 실행합니다. 작업이 완료되면, 미리 등록해 둔 **콜백 함수**가 호출되어 결과를 처리합니다. 이 방식은 "콜백 헬(Callback Hell)"이라 불리는 중첩된 콜백 구조를 만들 수 있습니다.

    **코드 사례 (`비동기식.js`):
    ```javascript
    const fs = require('fs');
    // readFile은 비동기로 동작합니다.
    fs.readFile('./동기식1.js', 'utf-8', function(error, data) {
        // 파일 읽기가 완료되면 이 콜백 함수가 실행됩니다.
        if (error) {
            return console.log(error);
        }
        console.log(data);
    });
    console.log("completed"); // readFile의 완료 여부와 상관없이 먼저 실행됨
    ```

### 3.2. `Promise`
- **`Promise`**: 콜백 헬 문제를 해결하고 비동기 코드를 더 깔끔하게 작성하기 위해 도입되었습니다. `Promise`는 비동기 작업의 최종 성공 또는 실패를 나타내는 객체입니다. `.then()`으로 성공 결과를, `.catch()`로 실패(에러)를 처리합니다.

    **코드 사례 (`프라미스1.js`):
    ```javascript
    const promise = new Promise(function(resolve, reject) {
        // 비동기 작업 시뮬레이션
        let sum = 0;
        for(let i = 1; i <= 10; i++) {
            sum += i;
        }
        if (sum > 0) {
            resolve(sum); // 성공 시 resolve 호출
        } else {
            reject("fail"); // 실패 시 reject 호출
        }
    });

    promise
        .then((response) => {
            console.log("성공:", response); // 55
            return response * 100; // 다음 then으로 값을 전달
        })
        .then((response) => {
            console.log("프라미스 체인:", response); // 5500
        })
        .catch(e => {
            console.log("실패:", e);
        })
        .finally(() => {
            console.log("작업 완료");
        });
    ```

### 3.3. `async/await`
- **`async/await`**: `Promise`를 더욱 동기 코드처럼 보이게 만들어 가독성을 극대화하는 최신 문법입니다. `async` 키워드를 함수 앞에 붙이면 해당 함수는 항상 `Promise`를 반환하며, 함수 내부에서 `await` 키워드를 사용하여 `Promise`가 완료될 때까지 기다릴 수 있습니다. **`await`는 `async` 함수 내에서만 사용할 수 있습니다.**

    **코드 사례 (`프라미스1.js`):
    ```javascript
    // Promise를 반환하는 함수
    function sigma(limit = 10) {
        return new Promise((resolve) => {
            let s = 0;
            for(let i = 1; i <= limit; i++) {
                s += i;
            }
            resolve(s);
        });
    }

    // async/await를 사용한 비동기 처리
    async function main() {
        console.log("작업 시작...");
        // sigma Promise가 완료될 때까지 기다림
        let result = await sigma(100);
        console.log("결과:", result);
        console.log("작업 종료");
    }

    main();
    ```

### 3.4. Fetch API 또는 Axios
- **Fetch API 또는 Axios**: 웹 애플리케이션에서 서버와 비동기적으로 통신하여 데이터를 주고받는 데 사용되는 주요 방법입니다. `XMLHttpRequest`보다 현대적이고 사용하기 편리합니다.
    - **Fetch API**: JavaScript에 내장된 비동기 HTTP 요청 API입니다. `Promise` 기반으로 동작하며, 별도의 라이브러리 설치 없이 사용할 수 있습니다.
        - `fetch(url, options)`: 네트워크 요청을 시작하고 `Promise`를 반환합니다.
        - `response.json()`: 응답을 JSON 형태로 파싱합니다.
        - `response.text()`: 응답을 텍스트 형태로 파싱합니다.

    **코드 사례 (Fetch API - GET 요청):
    ```javascript
    async function fetchData() {
        try {
            const response = await fetch('https://jsonplaceholder.typicode.com/posts/1');
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();
            console.log('Fetch Data:', data);
        } catch (error) {
            console.error('Fetch Error:', error);
        }
    }
    fetchData();
    ```

    **코드 사례 (Fetch API - POST 요청):
    ```javascript
    async function postData() {
        try {
            const response = await fetch('https://jsonplaceholder.typicode.com/posts', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ title: 'foo', body: 'bar', userId: 1 }),
            });
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();
            console.log('Post Data:', data);
        } catch (error) {
            console.error('Post Error:', error);
        }
    }
    postData();
    ```

    - **Axios**: Promise 기반의 HTTP 클라이언트 라이브러리입니다. 브라우저와 Node.js 환경에서 모두 사용할 수 있으며, 더 많은 기능(요청/응답 인터셉터, 자동 JSON 변환 등)을 제공하여 편리합니다.
        - 설치: `npm install axios` 또는 CDN 사용

    **코드 사례 (Axios - GET 요청):
    ```javascript
    // <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script> 필요
    async function getAxiosData() {
        try {
            const response = await axios.get('https://jsonplaceholder.typicode.com/posts/1');
            console.log('Axios Data:', response.data);
        } catch (error) {
            console.error('Axios Error:', error);
        }
    }
    getAxiosData();
    ```

    **코드 사례 (Axios - POST 요청):
    ```javascript
    async function postAxiosData() {
        try {
            const response = await axios.post('https://jsonplaceholder.typicode.com/posts', {
                title: 'foo',
                body: 'bar',
                userId: 1,
            });
            console.log('Axios Post Data:', response.data);
        } catch (error) {
            console.error('Axios Post Error:', error);
        }
    }
    postAxiosData();
    ```
  
### 3.5. WebSockets
WebSockets은 웹 브라우저와 서버 간에 **전이중(full-duplex) 통신 채널**을 제공하는 기술입니다. HTTP와 달리 한 번 연결이 수립되면 서버와 클라이언트가 독립적으로 데이터를 주고받을 수 있어, 실시간 웹 애플리케이션(채팅, 게임, 실시간 알림, 주식 시세 등) 구현에 필수적입니다.

- **주요 특징**:
    - **양방향 통신**: 클라이언트와 서버가 동시에 데이터를 주고받을 수 있습니다.
    - **지속적인 연결**: 한 번 연결되면 계속 유지되므로, HTTP의 요청-응답 방식보다 오버헤드가 적습니다.
    - **낮은 지연 시간**: 실시간 데이터 전송에 최적화되어 있습니다.

- **사용 방법**: JavaScript의 `WebSocket` API를 사용하여 클라이언트 측에서 WebSocket 연결을 생성하고 메시지를 주고받습니다.

**코드 사례 (클라이언트 측 WebSocket):**
```javascript
const socket = new WebSocket('ws://localhost:8080'); // WebSocket 서버 주소

// 연결이 열렸을 때
socket.addEventListener('open', function (event) {
    console.log('WebSocket 연결 성공!');
    socket.send('안녕하세요, 서버!');
});

// 서버로부터 메시지를 받았을 때
socket.addEventListener('message', function (event) {
    console.log('서버로부터 메시지 수신:', event.data);
});

// 에러 발생 시
socket.addEventListener('error', function (event) {
    console.error('WebSocket 에러 발생:', event);
});

// 연결이 닫혔을 때
socket.addEventListener('close', function (event) {
    console.log('WebSocket 연결 종료:', event.code, event.reason);
});

// 메시지 전송 함수
function sendMessage(message) {
    if (socket.readyState === WebSocket.OPEN) {
        socket.send(message);
    } else {
        console.warn('WebSocket이 연결되지 않았습니다.');
    }
}

// 예시: 5초 후 메시지 전송
setTimeout(() => {
  sendMessage('5초 후 메시지입니다.');
}, 5000);
```

**풀스택 관점**: WebSocket을 사용하려면 클라이언트 측 JavaScript 코드 외에도 WebSocket 프로토콜을 지원하는 서버(Node.js의 `ws` 라이브러리, Python의 `websockets`, Java의 Spring WebSocket 등)가 필요합니다.

### 3.6. JavaScript 런타임 환경 (브라우저 vs Node.js)
JavaScript는 웹 브라우저에서 동작하는 클라이언트 사이드 스크립트 언어로 시작했지만, Node.js의 등장으로 서버 사이드에서도 실행될 수 있게 되었습니다. 풀스택 개발자에게는 이 두 가지 주요 런타임 환경의 차이점을 이해하는 것이 중요합니다.

- **브라우저 환경**: 웹 페이지의 동적인 기능을 구현하는 데 사용됩니다. 브라우저는 JavaScript 엔진(예: Chrome의 V8, Firefox의 SpiderMonkey)과 함께 웹 API(DOM, Fetch API, Web Storage, Geolocation 등)를 제공하여 JavaScript가 웹 페이지와 상호작용할 수 있도록 합니다.
    - **주요 특징**: DOM 조작, 사용자 이벤트 처리, 웹 API 접근, 보안을 위한 샌드박스 환경.
    - **제한 사항**: 파일 시스템 직접 접근 불가, 네트워크 요청 시 CORS 제약.

- **Node.js 환경**: 서버 애플리케이션, CLI 도구, 빌드 시스템 등 브라우저 외부에서 JavaScript 코드를 실행할 수 있게 해주는 런타임입니다. V8 엔진을 기반으로 하며, 비동기 I/O를 통해 높은 처리량을 제공합니다.
    - **주요 특징**: 파일 시스템 접근, 네트워크 통신(HTTP 서버, TCP/UDP 소켓), 외부 라이브러리(npm) 사용 용이, 백엔드 로직 구현.
    - **제한 사항**: DOM 조작 불가, 브라우저 웹 API 접근 불가.

**풀스택 관점**: 프론트엔드 개발 시에는 브라우저 환경의 JavaScript를 사용하고, 백엔드 개발 시에는 Node.js 환경의 JavaScript를 사용합니다. 두 환경 모두 JavaScript를 사용하지만, 제공되는 API와 주요 활용 분야가 다르므로 이를 명확히 구분하여 개발해야 합니다.